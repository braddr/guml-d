? bestguml
? diff.log
? setup.c.prev
? stub
? test_hash
Index: Makefile
===================================================================
RCS file: /cvsroot_private/guml/Makefile,v
retrieving revision 1.11
diff -u -r1.11 Makefile
--- Makefile	3 Jan 2000 20:38:57 -0000	1.11
+++ Makefile	28 Mar 2003 07:25:01 -0000
@@ -4,7 +4,7 @@
 # TUXEDO = yes
  
 # define for fastcgi, comment out otherwise
-# FASTCGI = yes
+FASTCGI = yes
 
 # define for purify compilation
 # PURIFY = yes
@@ -12,12 +12,19 @@
 #define for quantify compilation
 # QUANTIFY = yes
 
+#define for using gprof
+# GPROF = yes
+
+#define for building optimized
+# OPTIMIZE = yes
+
 #define for various debugging flags
-# DEBUG_BUILD = yes
-# DEBUG_ENV = yes
+DEBUG_BUILD = yes
+DEBUG_ENV = no
+DEBUG_SQL = yes
 
 # MODE = DEVELOPMENT
-# MODE = PRODUCTION
+MODE = PRODUCTION
 
 # DB = SYBASE
 # DB = ORACLE
@@ -25,7 +32,7 @@
 # ORACLEV = 734
 # ORACLEV = 8
 # DB = KUBL
-# DB = INFORMIX
+DB = INFORMIX
 # DB = MYSQL
 
 # SITE = VISA_EXPO
@@ -41,10 +48,11 @@
 # SITE = TEACH
 # SITE = DOLE
 # SITE = DREYFUS
- 
+SITE = GUML_COM
+
 # OS = SOLARIS_251
 # OS = SOLARIS_26
-# OS = LINUX
+OS = LINUX
 # OS = AIX
 
 #=======================================
@@ -75,7 +83,7 @@
 endif
 
 ifeq (${SITE},TESTING)
-DEFINES += -DUSE_FILE_HANDLE_OPS
+DEFINES += -DUSE_FILE_HANDLE_OPS -DBRADDR_TESTING
 endif
 
 ifdef TUXEDO
@@ -164,15 +172,16 @@
 
 ifeq (${DB},INFORMIX)
 #INFORMIXDIR = /pkgs/informix7.13
-INFORMIXDIR = /usr/local/informix
+INFORMIXDIR = /home/informix
 ESQLFLAGS   = -I$(INFORMIXDIR)/incl/esql -L$(INFORMIXDIR)/lib/esql
 ESQL        = $(INFORMIXDIR)/bin/esql
 DB_CFLAGS   = -DUSE_INFORMIX -I$(INFORMIXDIR)/incl/esql
 DB_OBJS     = informix.o
 FINAL_CC    = $(ESQL)
 .SUFFIXES: .ec
-.ec.c:
-	$(ESQL) -e $(CFLAGS) $<
+.ec.o:
+	$(ESQL) -c $(CFLAGS) $<
+	rm -f $*.c
 endif
 
 ifeq (${DB},MYSQL)
@@ -201,29 +210,43 @@
 endif
 
 CFLAGS = $(DEFINES) $(DB_CFLAGS)
+ifdef GPROF
+CFLAGS += -pg
+endif
 ifdef DEBUG_BUILD
 CFLAGS += -Wall -g
 endif
 ifdef DEBUG_ENV
 CFLAGS += -DDEBUG_ENV
 endif
+ifdef DEBUG_SQL
+CFLAGS += -DDEBUG_SQL
+endif
 ifdef FASTCGI
-CFLAGS += -DFASTCGI -I/home/brad/fastcgi/fcgi2.0b2.1/include
+CFLAGS += -DFASTCGI -I/home/www-data/fcgi-src/fcgi-dev-kit/devkit_2.2.0/include
 endif
 ifdef TUXEDO
 CFLAGS += -DTUXEDO -I$(ROOTDIR)/../tpmsg -I$(ROOTDIR)/include -I$(ROOTDIR)/../libcsrv
 endif
+ifdef OPTIMIZE
+CFLAGS += -O
+ifeq (${OS},LINUX)
+CFLAGS += -fomit-frame-pointer
+endif
+endif
 
 CXXFLAGS = ${CFLAGS}
 
-O_FILES = setup.o engine.o commands.o env_ops.o dir_ops.o file_ops.o math_ops.o string_ops.o email.o hash_table.o prims.o www.o calculator.o string_utils.o site_specific_ops.o filehandle_ops.o $(DB_OBJS)
+O_FILES = setup.o engine.o commands.o env_ops.o dir_ops.o file_ops.o math_ops.o \
+          string_ops.o email.o hash_table.o prims.o www.o calculator.o string_utils.o \
+          site_specific_ops.o filehandle_ops.o $(DB_OBJS)
 ifdef TUXEDO
 O_FILES += tuxedo.o
 endif
 
 LIBS = ${OS_LIBS} ${DB_LIBS} ${OTHER_LIBS}
 ifdef FASTCGI
-LIBS += -L/home/brad/fastcgi/fcgi2.0b2.1/libfcgi -lfcgi
+LIBS += -L/home/www-data/fcgi-src/fcgi-dev-kit/devkit_2.2.0/libfcgi -lfcgi
 ifeq (${OS},SOLARIS_26)
 LIBS += -lsocket -lnsl
 endif
@@ -300,8 +323,7 @@
 endif
 
 ifeq (${DB},INFORMIX)
-informix.o: informix.c
-informix.c: informix.ec global.h local.h
+informix.o: informix.ec global.h local.h
 endif
 
 ifeq (${DB},MYSQL)
Index: bestguml.c
===================================================================
RCS file: /cvsroot_private/guml/bestguml.c,v
retrieving revision 1.13
diff -u -r1.13 bestguml.c
--- bestguml.c	5 Aug 1999 07:57:43 -0000	1.13
+++ bestguml.c	28 Mar 2003 07:25:01 -0000
@@ -5,11 +5,9 @@
 #include <stdlib.h>
 #include <string.h>
 #include <signal.h>
-#ifdef WIN32
-#  include <time.h>
-#else
+#include <time.h>
+#ifndef WIN32
 #  include <unistd.h>
-#  include <sys/time.h>
 #  include <sys/resource.h>
 #endif
 #include <sys/stat.h>
@@ -36,15 +34,15 @@
     guml_env = envp;
 
     srandom (time (NULL));
+    init_hash_table();
     init_commands ();
-    init_env();
 
 #ifdef FASTCGI
 #if defined(USE_SYBASE) || defined(USE_ORACLE) || defined(USE_KUBL) || defined(USE_INFORMIX) || defined(USE_MYSQL) || defined(USE_MSSQL)
     if ((err = sql_init()))
     {
         writelog("Error, unable to initialize the db: %s\n", err);
-        exit(1);
+        exit(10);
     }
 #endif
 
@@ -53,20 +51,26 @@
     guml_env = fcgi_envp;
 #endif
 
-    fatal_error = 0;
     setup_environment (argc, argv);
     init_engine();
+#ifdef BRADDR_TESTING
+    read_startup_config_file();
+    read_per_page_hit_config_file();
+#endif
+    fatal_error = 0;
+
 
     filename = find_hash_data ("FILENAME", calc_hash("FILENAME"))->data;
+    err = find_hash_data("BASE_DIR", calc_hash("BASE_DIR"))->data;  /* overloading usage of err */
 
 #ifndef LOG_ONLY_ERRORS
-    writelog("Parsing file: %s", filename);
+    writelog("Parsing file: %s%s", err, filename[0] == '/' ? filename+1 : filename);
 #endif
 
     if (strstr (filename, "..") != NULL)
     {
         FPUTS("Content-type: text/plain\n\nIllegal file name encountered!\n");
-        exit (1);
+        exit (2);
     }
 
     err = guml_file_include (&results, &filename, -1);
@@ -74,9 +78,10 @@
     error_data = find_hash_data ("ERROR", calc_hash("ERROR"));
     if (error_data && error_data->data)
     {
-        if (strstr(error_data->data, "Content-type") == NULL)
+	writelog("ERROR defined");
+        if (strstr(error_data->data, "Content-type:") == NULL)
         {
-            if (strstr(error_data->data, "Location") != NULL)
+            if (strstr(error_data->data, "Location:") != NULL)
                 FPUTS("Content-type: text/html\n");
             else
                 FPUTS("Content-type: text/html\n\n");
@@ -90,6 +95,7 @@
     {
         if ((err || fatal_error) && fatal_error != 2)
         {
+	    writelog("fatal_error = %d", fatal_error);
             if (err)
                 add_string(&err_string, err);
 
@@ -101,6 +107,7 @@
             }
             if (err_string.data)
             {
+		writelog("traceback: %s", err_string.data);
                 insert_hash(strdup("ERROR_traceback"), create_string(err_string.data, 1), calc_hash("ERROR_traceback"), 0);
                 err_string.data = NULL;
                 err_string.length = 0; 
@@ -112,6 +119,8 @@
             {
                 char *oops = "Content-type: text/plain\n\n\\get{ERROR_traceback}\n\nResults so far:\n\n\\get{ERROR_results}";
                 guml_backend (&results, &oops, NULL, 0);
+
+
                 if (err_string.data)
                 {
                     FPUTS("Content-type: text/plain\n\nFatal error parsing /handle-error\n");
@@ -135,19 +144,25 @@
                     FPUTS(results.data);
         }
         else
+        {
             if (results.data)
             {
-                if (strstr(results.data, "Content-type") == NULL)
+                if (strstr(results.data, "Content-type:") == NULL)
                 {
-                    if (strstr(results.data, "Location") != NULL)
+                    if (strstr(results.data, "Location:") != NULL)
                         FPUTS("Content-type: text/html\n");
                     else
                         FPUTS("Content-type: text/html\n\n");
                 }
                 FPUTS(results.data);
             }
+        }
     }
 
+#ifdef FASTCGI
+    FCGX_Finish();
+#endif
+
     if (err_string.data)
     {
         free(err_string.data);
@@ -160,15 +175,20 @@
         results.data  = NULL;
         results.length = 0;
     }
-    if (clean_filehandles())
-        writelog ("Failed to close a file handle.");
 
 #ifndef LOG_ONLY_ERRORS
     writelog ("Done parsing.");
 #endif
 
 #ifdef FASTCGI
+    if (clean_filehandles())
+        writelog ("Failed to close a file handle.");
+
+    guml_close_dir_internal();
+
     clean_hash(HASH_ALL);
+
+    sql_cleanup();
     }
 #endif
 
Index: commands.c
===================================================================
RCS file: /cvsroot_private/guml/commands.c,v
retrieving revision 1.9
diff -u -r1.9 commands.c
--- commands.c	14 Oct 1999 19:19:50 -0000	1.9
+++ commands.c	28 Mar 2003 07:25:01 -0000
@@ -1,4 +1,6 @@
 #include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
 
 #include "global.h"
 
@@ -16,6 +18,7 @@
 #endif
     {"cmode",		{guml_cmode},			CMD_ARGS },
     {"date",		{guml_date},			CMD_ARGS },
+    {"dirclose",        {guml_close_dir},               CMD_ARGS },
     {"diropen",         {guml_open_dir},                CMD_ARGS },
     {"dirread",         {guml_read_dir},                CMD_ARGS },
     {"email",		{guml_email},			CMD_ARGS },
@@ -94,8 +97,9 @@
 
 void init_commands(void)
 {
-    struct command *mycommand = commlist;
-
-    while (mycommand[num_commands].thecomm != NULL)
-        num_commands++;
+    int i;
+     
+    for (i = 0; commlist[i].thecomm != NULL; i++)
+        insert_hash(strdup(commlist[i].thecomm), (Data*)(&commlist[i]), calc_hash(commlist[i].thecomm),
+                    HASH_BUILTIN | HASH_READONLY);
 }
Index: dir_ops.c
===================================================================
RCS file: /cvsroot_private/guml/dir_ops.c,v
retrieving revision 1.2
diff -u -r1.2 dir_ops.c
--- dir_ops.c	5 Aug 1999 08:29:25 -0000	1.2
+++ dir_ops.c	28 Mar 2003 07:25:01 -0000
@@ -11,24 +11,34 @@
 
 DIR *mydir = NULL;
 
-int guml_close_dir ()
+int guml_close_dir_internal ()
 {
-    int rc;
+    int rc = 0;
 
-    rc = closedir(mydir);
-    mydir = NULL;
+    if (mydir)
+    {
+        rc = closedir(mydir);
+        mydir = NULL;
+    }
 
     return rc;
 }
+    
+char *guml_close_dir (Data *out_string, char *args[], int nargs)
+{
+    if (nargs != 0)
+        return "\\closedir requires no parameters";
+
+    guml_close_dir_internal();
+    return NULL;
+}       
 
 char *guml_open_dir (Data *out_string, char *args[], int nargs)
 {
     if (nargs != 1)
         return "\\opendir requires only one parameter";
 
-    if (mydir)
-        guml_close_dir();
-
+    guml_close_dir_internal();
     mydir = opendir(args[0]);
     if (!mydir)
         return NULL;
@@ -47,7 +57,7 @@
     mydirent = readdir(mydir);
     if (!mydirent)
     {
-        guml_close_dir();
+        guml_close_dir_internal();
         return NULL;
     }
 
Index: engine.c
===================================================================
RCS file: /cvsroot_private/guml/engine.c,v
retrieving revision 1.4
diff -u -r1.4 engine.c
--- engine.c	20 Feb 1998 02:40:15 -0000	1.4
+++ engine.c	28 Mar 2003 07:25:01 -0000
@@ -19,8 +19,6 @@
 
 #define MAXDEPTH	100
 
-extern int num_commands;
-
 Data err_string;
 int modetrigger;
 int depth;
@@ -39,32 +37,19 @@
     free_err_res = 0;
 }
 
-struct command *guml_find_command (char *command)
-{
-    int first, last, middle, result;
-
-    first = 0;
-    last = num_commands - 1;
-    do
-    {
-        middle = (last + first) / 2;
-        result = strcmp (command, commlist[middle].thecomm);
-        if (result == 0)
-            return &commlist[middle];
-        else if (result < 0)
-            last = middle - 1;
-        else
-            first = middle + 1;
-    }
-    while (first <= last);
-
-    return NULL;
-}
+#define dump_accumulate(__from, __to, __num) \
+    do { \
+        if (__num) \
+        { \
+            add_string_size(__from, __to-__num, __num); \
+            __num = 0; \
+        } \
+    } while (0)
 
 char *guml_parse_params (char **ins, char **params, int numparams, char ***args, int *nargs, int quoted)
 {
     char *cur, *err = NULL;
-    long size;
+    unsigned long accumulate = 0;
 
     cur = *ins;
 
@@ -91,28 +76,29 @@
                 {
                     case '{':
                         nesting++;
-                        add_char (&t, *cur);
+                        accumulate++;
                         break;
                     case '}':
                         nesting--;
                         if (nesting >= 0)
-                            add_char (&t, *cur);
+                            accumulate++;
                         break;
                     case '#':
                         if (prev != '\\')
                         {
-                            char *t;
+                            char *tmp;
 
                             notws = 0;
-                            t = strchr(cur, '\n');
-                            cur = t ? t : &(cur[strlen(cur)-1]);
+                            dump_accumulate(&t, cur, accumulate);
+                            tmp = strchr(cur, '\n');
+                            cur = tmp ? tmp : &(cur[strlen(cur)-1]);
                         }
                         else
-                            /*t.data[t.length-2] = '#';*/ add_char (&t, *cur);
+                            accumulate++;
                         break;
                     case '\n':
                         notws = 0;
-                        add_char (&t, *cur);
+                        accumulate++;
                         break;
                     case '\f':
                     case '\r':
@@ -120,21 +106,23 @@
                     case '\v':
                     case ' ':
                         if (notws)
-                            add_char (&t, *cur);
+                            accumulate++;
+                        else
+                            dump_accumulate(&t, cur, accumulate);
                         break;
                     default:
                         notws = 1;
-                        add_char (&t, *cur);
+                        accumulate++;
                 }
                 prev = *cur;
                 cur++;
             }
             cur--;
+            dump_accumulate(&t, cur, accumulate);
             (*args)[*nargs] = t.data;
         }
         else
         {
-            size = 0;
             guml_backend (&t, &cur, params, numparams);
             (*args)[*nargs] = t.data;
             if (fatal_error)
@@ -161,6 +149,7 @@
 
 void guml_backend (Data *out_string, char **ins, char *params[], int numparams)
 {
+    unsigned long accumulate = 0;
     int quit = 0, notws = 1, line = 1;
     char *cur;
     wsw wsmode = cmode;
@@ -169,7 +158,7 @@
     if (depth >= MAXDEPTH)
     {
         printf ("Content-type: text/plain\n\nMAXIMUM DEPTH REACHED: PROBABLY AN INFINITE LOOP!  BAILING!!!\n");
-        exit (1);
+        exit (3);
     }
 
     cur = *ins;
@@ -182,7 +171,9 @@
                 line++;
                 notws = 0;
                 if (wsmode == tmode)
-                    add_char (out_string, *cur);
+                    accumulate++;
+                else
+                    dump_accumulate(out_string, cur, accumulate);
                 break;
 
             case ' ':
@@ -191,10 +182,13 @@
             case '\t':
             case '\v':
                 if (notws && (wsmode == tmode))
-                    add_char (out_string, *cur);
+                    accumulate++;
+                else
+                    dump_accumulate(out_string, cur, accumulate);
                 break;
 
             case '#':
+                dump_accumulate(out_string, cur, accumulate);
                 {
                     char *t;
 
@@ -205,6 +199,7 @@
                 break;
 
             case '{':
+                dump_accumulate(out_string, cur, accumulate);
                 notws = 1;
                 cur++;
                 guml_backend (out_string, &cur, params, numparams);
@@ -213,18 +208,19 @@
                 break;
 
             case '}':
+                dump_accumulate(out_string, cur, accumulate);
                 quit = 1;
                 notws = 1;
                 break;
 
             case '\\':
+                dump_accumulate(out_string, cur, accumulate);
                 {
                     char command[100];
                     unsigned long hash_value = 0;
                     int i;
 
                     notws = 1;
-                    command[0] = 0;
                     i = 0;
                     cur++;
                     while (*cur && ((*cur >= 'A' && *cur <= 'Z') || (*cur >= 'a' && *cur <= 'z') || *cur == '_') && i < 99)
@@ -238,15 +234,15 @@
 
                     if (*command)
                     {
-                        struct command *myfunction = NULL;
+                        struct command *mycmd = NULL;
+                        HashNode *myfunction;
+                        int quoteargs = 0, nargs = 0;
                         char **args = NULL, *err;
-                        int nargs = 0, quoteargs = 0;
 
-                        if ((myfunction = guml_find_command (command)) != NULL)
-                        {
-                            if (myfunction->cmd_flags & CMD_QUOTED)
+                        if ((myfunction = find_hash_node(command, hash_value)) != NULL)
+                            if (myfunction->flags & HASH_BUILTIN &&
+                                (mycmd = ((struct command*)(myfunction->data)))->cmd_flags & CMD_QUOTED)
                                 quoteargs = 1;
-                        }
 
                         err = guml_parse_params (&cur, params, numparams, &args, &nargs, quoteargs);
                         if (err || fatal_error)
@@ -257,26 +253,7 @@
                                 fatal_error = 1;
                             if (err)
                             {
-                                switch(free_err_res)
-                                {
-                                    case 0:
-                                        add_string(&err_string, err);
-                                        break;
-                                    case 1:
-                                        add_string(&err_string, *((char**)err));
-                                        free(*((char**)err));
-                                        *((char**)err) = NULL;
-                                        free_err_res = 0;
-                                        break;
-                                    case 2:
-                                        add_string(&err_string, err);
-                                        free(err);
-                                        free_err_res = 0;
-                                        break;
-                                    default:
-                                        add_string(&err_string, "CRITICAL ERROR -- missing free_err_res case #2");
-                                        free_err_res = 0;
-                                }
+                                add_string(&err_string, err);
                                 add_char(&err_string, '\n');
                             }
                             sprintf(tmp, "   ... while parsing parameters for '%s' at line %d.\n", command, line);
@@ -286,93 +263,89 @@
 
                         if (myfunction)
                         {
-                            char *err = NULL;
-
-#ifdef DEBUG
-                            printf ("Calling function \"%s\" with %d args\n", command, nargs);
-#endif
-                            if (myfunction->cmd_flags & CMD_ARGS)
-                                if (myfunction->cmd_flags & CMD_PARAMS)
-                                    err = (*myfunction->cmd.c_arg_param)(out_string, args, nargs, params, numparams);
+                            if (myfunction->flags & HASH_BUILTIN)
+                            {
+                                if (mycmd->cmd_flags & CMD_ARGS)
+                                    if (mycmd->cmd_flags & CMD_PARAMS)
+                                        err = (*mycmd->cmd.c_arg_param)(out_string, args, nargs, params, numparams);
+                                    else
+                                        err = (*mycmd->cmd.c_arg)(out_string, args, nargs);
                                 else
-                                    err = (*myfunction->cmd.c_arg)(out_string, args, nargs);
-                            else
-                                err = "Unknown function type, no args or params";
+                                    err = "Unknown function type, no args or params";
 
-                            if (modetrigger != 0)
-                            {
-                                wsmode = modetrigger == 1 ? cmode : tmode;
-                                modetrigger = 0;
-                            }
+                                if (modetrigger != 0)
+                                {
+                                    wsmode = modetrigger == 1 ? cmode : tmode;
+                                    modetrigger = 0;
+                                }
 
-                            if (err || fatal_error)
+                            }
+                            else
                             {
-                                char tmp[1024];
+                                Data *env_data;
+                                char *env_str, *str;
 
-                                if (!fatal_error)
-                                    fatal_error = 1;
-                                if (err)
+                                env_data = myfunction->data;
+                                if (env_data && (env_str = env_data->data))
                                 {
-                                    switch(free_err_res)
-                                    {
-                                        case 0:
-                                            add_string (&err_string, err);
-                                            break;
-                                        case 1:
-                                            add_string (&err_string, *((char**)err));
-                                            free(*((char**)err));
-                                            *((char**)err) = NULL;
-                                            free_err_res = 0;
-                                            break;
-                                        case 2:
-                                            add_string (&err_string, err);
-                                            free(err);
-                                            free_err_res = 0;
-                                            break;
-                                        default:
-                                            add_string(&err_string, "CRITICAL ERROR -- missing free_err_res case #3");
-                                            free_err_res = 0;
-                                    }
-                                    add_char (&err_string, '\n');
+                                    str = strdup(env_str);
+                                    env_str = str;
+                                    guml_backend (out_string, &str, args, nargs);
+                                    free(env_str);
                                 }
-                                sprintf(tmp, "   ... while processing '%s' at line %d.\n", command, line);
-                                add_string (&err_string, tmp);
                             }
                         }
                         else
                         {
-                            Data *env_data;
-                            char *env_str;
-#ifdef DEBUG
-                            printf ("Parsing macro \"%s\" with %d args\n", command, nargs);
-#endif
+                            char buffer[128];
 
-                            env_data = find_hash_data (command, hash_value);
-                            if (env_data && (env_str = env_data->data))
-                            {
-                                char *str;
+                            if (!fatal_error)
+                                fatal_error = 1;
+                            sprintf (buffer, "Undefined macro \"%s\" invoked.\n", command);
+                            add_string (&err_string, buffer);
+                        }
 
-                                str = strdup(env_str);
-                                env_str = str;
-                                guml_backend (out_string, &str, args, nargs);
-                                free(env_str);
-                                if (fatal_error)
-                                {
-                                    char tmp[1024];
+                        if (err || fatal_error)
+                        {
+                            char tmp[1024];
 
-                                    sprintf(tmp, "   ... while processing '%s' at line %d.\n", command, line);
-                                    add_string (&err_string, tmp);
+                            if (!fatal_error)
+                                fatal_error = 1;
+                            if (err)
+                            {
+                                switch(free_err_res)
+                                {
+                                    case 0:
+                                        add_string (&err_string, err);
+                                        break;
+                                    case 1:
+                                        add_string (&err_string, *((char**)err));
+                                        free(*((char**)err));
+                                        *((char**)err) = NULL;
+                                        free_err_res = 0;
+                                        break;
+                                    case 2:
+                                        add_string (&err_string, err);
+                                        free(err);
+                                        free_err_res = 0;
+                                        break;
+                                    default:
+                                        add_string(&err_string, "CRITICAL ERROR -- missing free_err_res case #3");
+                                        free_err_res = 0;
                                 }
+                                add_char (&err_string, '\n');
                             }
-                            else
+                            add_string_size(&err_string, "   ... while processing '", 25);
+                            add_string(&err_string, command);
+                            if (!strcmp(command, "include"))
                             {
-                                char buffer[128];
-
-                                if (!fatal_error)
-                                    fatal_error = 1;
-                                sprintf (buffer, "Undefined macro \"%s\" invoked.\n", command);
-                                add_string (&err_string, buffer);
+                                add_string_size(&err_string, "' of file '", 11);
+                                add_string(&err_string, args[0]);
                             }
+                            add_string_size(&err_string, "' at line ", 10);
+                            sprintf(tmp, "%d", line);
+                            add_string(&err_string, tmp);
+                            add_string_size(&err_string, ".\n", 2);
                         }
 
                       cleanup_params:
@@ -387,9 +360,9 @@
                         {
                             command[i] = *cur;
                             i++;
-                            command[i] = 0;
                             cur++;
                         }
+                        command[i] = 0;
                         if (*command)
                         {
                             cur--;
@@ -400,7 +373,7 @@
                         else
                         {
                             wsmode = tmode;
-                            add_char (out_string, *cur);
+                            accumulate++;
                         }
                     }
                 }
@@ -409,12 +382,12 @@
             default:
                 wsmode = tmode;
                 notws = 1;
-                add_char (out_string, *cur);
+                accumulate++;
         }
-
         if (!quit && !fatal_error)
             cur++;
     }
+    dump_accumulate(out_string, cur, accumulate);
 
     *ins = cur;
 
Index: file_ops.c
===================================================================
RCS file: /cvsroot_private/guml/file_ops.c,v
retrieving revision 1.9
diff -u -r1.9 file_ops.c
--- file_ops.c	15 Oct 1999 22:57:48 -0000	1.9
+++ file_ops.c	28 Mar 2003 07:25:01 -0000
@@ -15,8 +15,6 @@
 
 #include "global.h"
 
-extern int free_err_res;
-
 #ifdef FASTCGI
     extern FCGX_Stream *fcgi_out;
 #endif
@@ -36,6 +34,7 @@
         return "\\filedelete -- not authenticated";
 
     sprintf (buffer, "%s%s", FILE_WRITE_DIR, args[0]);
+    writelog ("guml_file_delete() called: %s", buffer);
     unlink (buffer);
     return NULL;
 }
@@ -56,6 +55,7 @@
         return "\\filewrite -- not authenticated";
 
     sprintf (buffer, "%s%s", FILE_WRITE_DIR, args[0]);
+    writelog ("guml_file_write() called: %s", buffer);
     if ((fp = fopen (buffer, "w")) == NULL)
         return "\\filewrite -- unable to write file";
 
@@ -67,7 +67,7 @@
 
 char *guml_file_read (Data *out_string, char *args[], int nargs)
 {
-    Data file_text = {NULL, 0};
+    Data file_text = {NULL, 0}, *base_dir;
     FILE *fp;
     char buffer[1024];
 
@@ -77,7 +77,15 @@
     if (strstr (args[0], "../") != NULL)
         return "\\fileread -- illegal filename, may not contain ..'s";
 
-    sprintf (buffer, "%s%s", DATAROOT, (args[0][0] == '/') ? args[0] + 1 : args[0]);
+    base_dir = find_hash_data("BASE_DIR", calc_hash("BASE_DIR"));
+    if (!base_dir)
+        return "\\include -- no BASE_DIR set";
+    if (!base_dir->data)
+        return "\\include -- BASE_DIR contains nothing";
+ 
+    sprintf (buffer, "%s%s", base_dir->data, (args[0][0] == '/') ? args[0] + 1 : args[0]);
+    writelog ("guml_file_read() called: %s", buffer);
+
     if ((fp = fopen (buffer, "r")) == NULL)
         return NULL;
 
@@ -94,6 +102,7 @@
 {
     FILE *fp;
     char buffer[1024];
+    Data *base_dir;
 
     if (nargs != 1)
         return "\\fileexists requires only 1 parameter";
@@ -101,7 +110,15 @@
     if (strstr (args[0], "../") != NULL)
         return "\\fileexists -- illegal filename, may not contain ..'s";
 
-    sprintf (buffer, "%s%s", DATAROOT, (args[0][0] == '/') ? args[0] + 1 : args[0]);
+    base_dir = find_hash_data("BASE_DIR", calc_hash("BASE_DIR"));
+    if (!base_dir)
+        return "\\include -- no BASE_DIR set";
+    if (!base_dir->data)
+        return "\\include -- BASE_DIR contains nothing";
+ 
+    sprintf (buffer, "%s%s", base_dir->data, (args[0][0] == '/') ? args[0] + 1 : args[0]);
+    writelog ("guml_file_exists() called: %s", buffer);
+
     if ((fp = fopen (buffer, "r")) != NULL)
     {
         fclose (fp);
@@ -114,6 +131,7 @@
 {
     char buffer[1024];
     struct stat statstr;
+    Data *base_dir;
 
     if (nargs != 2)
         return "\\filestatus requires 2 parameters";
@@ -121,7 +139,15 @@
     if (strstr (args[0], "../") != NULL)
         return "\\filestatus -- illegal filename, may not contain ..'s";
 
-    sprintf (buffer, "%s%s", DATAROOT, (args[0][0] == '/') ? args[0] + 1 : args[0]);
+    base_dir = find_hash_data("BASE_DIR", calc_hash("BASE_DIR"));
+    if (!base_dir)
+        return "\\include -- no BASE_DIR set";
+    if (!base_dir->data)
+        return "\\include -- BASE_DIR contains nothing";
+ 
+    sprintf (buffer, "%s%s", base_dir->data, (args[0][0] == '/') ? args[0] + 1 : args[0]);
+    writelog ("guml_file_status() called: %s", buffer);
+
     if (stat (buffer, &statstr) == -1)
         return strerror (errno);
 
@@ -178,7 +204,7 @@
 {
     struct stat mystat;
     FILE *g;
-    char myfile[1024];
+    char myfile[1024], filenotfound[1024];
     Data *base_dir;
     static char errstr[1024];
  
@@ -188,7 +214,7 @@
     if (strstr (args[0], "../") != NULL)
     {
         FPUTS("Content-type: text/plain\n\nIllegal file name encountered!\n");
-        exit (1);
+        exit (4);
     }
 
     base_dir = find_hash_data("BASE_DIR", calc_hash("BASE_DIR"));
@@ -199,15 +225,15 @@
  
     sprintf (myfile, "%s%s", base_dir->data, (args[0][0] == '/') ? args[0] + 1 : args[0]);
     if (stat(myfile, &mystat))
-     {
+    {
 #if !defined(GUMLHEADERROOT) || !defined(GUMLHEADERDIR)
         goto file_error;
 #else
-      /* If the file is not found in guml root, see if the string specifies
-      /* that it is in an alternative header directory (GUMLHEADERDIR) and 
-      /* look in the alternative header root (GUMLHEADERROOT).  This means
-      /* that even header files in the header root must specify the "full
-      /* path" when including other headers by using the header directory. */
+        /* If the file is not found in guml root, see if the string specifies *
+         * that it is in an alternative header directory (GUMLHEADERDIR) and  *
+         * look in the alternative header root (GUMLHEADERROOT).  This means  *
+         * that even header files in the header root must specify the "full   *
+         * path" when including other headers by using the header directory.  */
         if (strstr (args[0], GUMLHEADERDIR) != NULL)
         {
            sprintf (myfile, "%s%s", GUMLHEADERROOT, 
@@ -217,7 +243,8 @@
            if (stat(myfile, &mystat))
               goto file_error;
         }
-        else goto file_error;       
+        else
+            goto file_error;       
 #endif
     }
     if (mystat.st_mode & S_IFDIR)
@@ -237,7 +264,8 @@
         }
  
 file_error:
-    if ((g = fopen ("file-not-found", "r")) == NULL)
+    sprintf (filenotfound, "%sfile-not-found", base_dir->data);
+    if ((g = fopen (filenotfound, "r")) == NULL)
     { 
         sprintf(errstr, "\\include -- file not found (%s)", myfile);
         return errstr;
Index: global.h
===================================================================
RCS file: /cvsroot_private/guml/global.h,v
retrieving revision 1.11
diff -u -r1.11 global.h
--- global.h	14 Oct 1999 19:19:36 -0000	1.11
+++ global.h	28 Mar 2003 07:25:01 -0000
@@ -13,9 +13,11 @@
 #include "local.h"
 
 #if defined(__SUNPRO_C) || defined(__SUNPRO_CC) || defined(WIN32)
-#define inline
+#define INLINE
 #define srandom srand
 #define random  rand
+#else
+#define INLINE inline
 #endif
 
 #ifdef NEED_RANDOM
@@ -23,21 +25,24 @@
 extern int random(void);
 #endif
 
-#define CMD_ARGS         0x00000001
-#define CMD_PARAMS       0x00000002
-#define CMD_QUOTED       0x00000004
- 
+#define CMD_ARGS        0x00000001
+#define CMD_PARAMS      0x00000002
+#define CMD_QUOTED      0x00000004
+
 #define STACK_INCREMENT 16
 #define STACK_MASK      (unsigned long)(-STACK_INCREMENT)
 #define HASH_WIDTH      509
 #define HASH_DEPTH      16
 #define HASH_MASK       (unsigned long)(-HASH_DEPTH)
 
-#define HASH_ENV        0x000000001
-#define HASH_COOKIE     0x000000002
-#define HASH_FORM       0x000000004
-#define HASH_ARG        0x000000008
-#define HASH_ALL        0x00000001F
+#define HASH_ENV        0x00000001
+#define HASH_COOKIE     0x00000002
+#define HASH_FORM       0x00000004
+#define HASH_ARG        0x00000008
+#define HASH_ALL        0x0000001F
+
+#define HASH_BUILTIN    0x40000000
+#define HASH_READONLY   0x80000000
 
 typedef struct data_struct
 {
@@ -71,17 +76,17 @@
 #endif
 
 /* hash_table.h */
-extern unsigned long calc_hash(char *str);
 extern void calc_hash_increment(unsigned long *hash_value, char c);
-extern void init_env(void);
+extern void init_hash_table(void);
 extern void push_stack(Data *data);
 extern Data *pop_stack(void);
 extern void shrink_stack(void);
-extern HashNode *find_hash_node(char *key, unsigned long hash);
 extern Data *find_hash_data(char *key, unsigned long hash);
-extern void insert_hash(char *key, Data *data, unsigned long hash, unsigned long flags);
+extern int  insert_hash(char *key, Data *data, unsigned long hash, unsigned long flags);
 extern void delete_hash(char *key, unsigned long hash);
 extern void clean_hash(unsigned long flags);
+extern HashNode *find_hash_node(char *key, unsigned long hash);
+extern unsigned long calc_hash(char *str);
 
 #ifdef DEBUG_STACK
 extern void stack_info(void);
@@ -91,10 +96,11 @@
 #endif
 
 /* setup.c */
-extern void setup_args (int iscomm, int argc, char *argv[]);
-extern void setup_form_args (void);
-extern void setup_cookie_args (void);
 extern void setup_environment (int argc, char *argv[]);
+#ifdef BRADDR_TESTING
+extern void read_startup_config_file(void);
+extern void read_per_page_hit_config_file(void);
+#endif
 
 /* string_utils.c */
 extern void writelog(char *msg, ...);
@@ -152,6 +158,7 @@
 commfunc_args guml_file_exists;
 commfunc_args guml_file_status;
 commfunc_args guml_file_include;
+extern void guml_file(Data *, FILE *);
  
 /* additional filehandle operations from filehandle_ops.c */
 commfunc_args guml_filehandle_output;
@@ -183,6 +190,7 @@
 extern char *sql_init_environ(void);
 #endif
 extern char *sql_init(void);
+extern char *sql_cleanup(void);
 extern char *sql_shutdown(void);
 commfunc_args guml_sqlexec;
 commfunc_args guml_sqlrow;
@@ -210,6 +218,8 @@
 commfunc_args guml_open_dir;
 commfunc_args guml_read_dir;
 commfunc_args guml_isdir;
+commfunc_args guml_close_dir;
+extern int guml_close_dir_internal();
 
 /* env_ops.h */
 commfunc_args guml_environ;
Index: hash_table.c
===================================================================
RCS file: /cvsroot_private/guml/hash_table.c,v
retrieving revision 1.1
diff -u -r1.1 hash_table.c
--- hash_table.c	5 Aug 1999 07:48:56 -0000	1.1
+++ hash_table.c	28 Mar 2003 07:25:01 -0000
@@ -6,11 +6,12 @@
 
 Data		**stack;
 HashNode	*hash_table[HASH_WIDTH];
-unsigned int	stack_depth, stack_allocated, hash_depths[HASH_WIDTH], hash_allocated[HASH_WIDTH], dupes;
+unsigned int	stack_depth, stack_allocated, hash_depths[HASH_WIDTH], hash_allocated[HASH_WIDTH], dupes, readonly;
 
-void init_env(void)
+void init_hash_table(void)
 {
 	dupes = 0;
+    readonly = 0;
 	stack_depth = 0;
 	stack_allocated = 0;
 	stack = NULL;
@@ -28,7 +29,7 @@
 		if (!stack)
 		{
 			printf("Content-type: text/plain\n\nFatal error, unable to grow stack, bailing!!!\n");
-			exit(1);
+			exit(5);
 		}
 	}
 	stack[stack_depth++] = data;
@@ -46,7 +47,7 @@
 {
 	if (stack_allocated != 0)
 	{
-		stack_allocated = ((stack_depth & STACK_MASK) + 1)  * STACK_INCREMENT;
+		stack_allocated = ((stack_depth & STACK_MASK) + 1) * STACK_INCREMENT;
 		stack = realloc(stack, sizeof(Data*) * stack_allocated);
 	}
 }
@@ -77,7 +78,7 @@
 			j++;
 		}
 	printf("buckets with data: %d\n", j);
-        printf("total entries: %d\n", k);
+    printf("total entries: %d\n", k);
 	printf("min entries: %d\n", min);
 	printf("max entries: %d\n", max);
 
@@ -92,7 +93,7 @@
 }
 #endif
 
-void calc_hash_increment(unsigned long *hash_value, char c)
+INLINE void calc_hash_increment(unsigned long *hash_value, char c)
 {
 	*hash_value = (*hash_value << 4) + c;
 }
@@ -135,13 +136,18 @@
 		return NULL;
 }
 
-void insert_hash(char *key, Data *data, unsigned long hash, unsigned long flags)
+int insert_hash(char *key, Data *data, unsigned long hash, unsigned long flags)
 {
 	HashNode *tmp_node;
 	unsigned int bucket;
 
 	if ((tmp_node = find_hash_node(key, hash)))
 	{
+        if (tmp_node->flags & HASH_READONLY)
+        {
+            readonly++;
+            return 1;
+        }
 		free(key);
 		free(tmp_node->data->data);
 		free(tmp_node->data);
@@ -157,7 +163,7 @@
 			if (!hash_table[bucket])
 			{
 				printf("Content-type: text/plain\n\nError growing hash table, bailing!\n");
-				exit(1);
+				exit(6);
 			}
 		}
 		tmp_node = &(hash_table[bucket][hash_depths[bucket]]);
@@ -167,6 +173,7 @@
 	}
 	tmp_node->data = data;
 	tmp_node->flags = flags;
+    return 0;
 }
 
 void delete_hash(char *key, unsigned long hash)
@@ -178,7 +185,7 @@
 	while (tmp && i < hash_depths[bucket] && strcmp(tmp[i].key, key) != 0)
 		i++;
 
-	if (i < hash_depths[bucket])
+	if (i < hash_depths[bucket] && !(hash_table[bucket][i].flags & HASH_READONLY))
 	{
 		free(hash_table[bucket][i].data->data);
 		free(hash_table[bucket][i].data);
@@ -188,21 +195,33 @@
 	}
 }
 
+// Warning, this code assumes that all the builtin's are first in the hash buckets
 void clean_hash(unsigned long flags)
 {
-	unsigned int i, j;
+	unsigned int i, j, num_builtin;
 
 	for (i=0; i<HASH_WIDTH; i++)
 	{
+        num_builtin = 0;
 		for (j=0; j<hash_depths[i]; j++)
 		{
-			free(hash_table[i][j].data->data);
-			free(hash_table[i][j].data);
-			free(hash_table[i][j].key);
+            if (hash_table[i][j].flags & HASH_BUILTIN)
+                num_builtin++;
+            else
+            {
+			    free(hash_table[i][j].data->data);
+			    free(hash_table[i][j].data);
+			    free(hash_table[i][j].key);
+		    }
 		}
-		free(hash_table[i]);
-		hash_table[i] = NULL;
-		hash_depths[i] = 0;
-		hash_allocated[i] = 0;
+        if (num_builtin)
+            hash_depths[i] = num_builtin;
+        else
+        {
+		    free(hash_table[i]);
+		    hash_table[i]     = NULL;
+		    hash_depths[i]    = 0;
+		    hash_allocated[i] = 0;
+	    }
 	}
 }
Index: informix.ec
===================================================================
RCS file: /cvsroot_private/guml/informix.ec,v
retrieving revision 1.7
diff -u -r1.7 informix.ec
--- informix.ec	31 Aug 1999 06:09:51 -0000	1.7
+++ informix.ec	28 Mar 2003 07:25:01 -0000
@@ -130,7 +130,9 @@
 
 char *sql_init()
 {
+#ifdef DB_DB
     $char db_name[128];
+#endif
 #ifdef DB_USER
     $char db_user[128], db_password[128];
 #endif
@@ -139,6 +141,11 @@
     if (sql_initted)
         return "SQL Environment already initialized.. should never happen";
 
+#if defined(NEED_SQL_ENVIRONMENT)
+    sql_init_environ ();
+#endif
+
+#ifdef DB_DB
     strcpy(db_name, DB_DB);
 #ifdef DB_USER
     strcpy(db_user, DB_USER);
@@ -147,6 +154,7 @@
 #else
     EXEC SQL connect to :db_name;
 #endif
+#endif
     if ((tmp = reporterror("sql_init", "connect", SQLCODE)) != NULL)
     {
         free_err_res = 2;
@@ -157,6 +165,21 @@
     return NULL;
 }
 
+char *sql_cleanup()
+{
+#ifndef DB_DB
+    char *tmp;
+
+    EXEC SQL close database;
+    if ((tmp = reporterror("sql_init", "connect", SQLCODE)) != NULL)
+    {
+        free_err_res = 2;
+        return tmp;
+    }
+#endif
+    return NULL;
+}
+
 char *sql_shutdown()
 {
     char *tmp;
@@ -203,6 +226,9 @@
     $int    i;
     $short  type;
     $struct loc_list_t *temp_desc;
+#if defined(DEBUG_SQL)
+    Data *debug_sql;
+#endif
 
     if (nargs < 1)
         return "\\sqlexec requires atleast 1 parameter";
@@ -219,6 +245,16 @@
 
     sql_exec_started = 1;
 
+#if defined(DEBUG_SQL)
+    debug_sql = find_hash_data("DEBUG_SQL", calc_hash("DEBUG_SQL"));
+    if (debug_sql && debug_sql->data)
+    {
+	writelog("sqlexec:");
+	for (i = 0; i < nargs; i++)
+	    writelog("    %s\n", args[i]); 
+    }
+#endif
+
     /* prepare statement id */
     tmp = args[0];
     sql_query = strdup(tmp);
@@ -354,7 +390,7 @@
         EXEC SQL get descriptor 'guml_desc' VALUE :i :type = TYPE, :name = NAME;
         if (type == SQLTEXT || type == SQLBYTES)
         {
-            temp_desc = get_new_descriptor(1);
+            temp_desc = get_new_descriptor(0);
             EXEC SQL set descriptor 'guml_desc' VALUE :i DATA = :temp_desc->ptr;
         }
     }
Index: local.h
===================================================================
RCS file: /cvsroot_private/guml/local.h,v
retrieving revision 1.12
diff -u -r1.12 local.h
--- local.h	19 Jan 2000 04:12:39 -0000	1.12
+++ local.h	28 Mar 2003 07:25:01 -0000
@@ -47,13 +47,29 @@
 #endif
 
 #ifdef SITE_TESTING
-#  define ACCTROOT "/home/brad/sandbox/guml"
+#  define ACCTROOT "/home/www-data/root"
+#  define DB_HOST        "burnboy_shm"
+#  define DB_DB          "website"
+#  define DB_ROOT        "/home/informix"
+#  define LOGFILE        "/tmp/guml_logfile"
+#  define DATAROOT       ACCTROOT "/"
+#  define GUMLROOT       ACCTROOT "/"
+#  define EXECGUML       ACCTROOT "/cgi-bin/actualbestguml"
 #  define USE_STANDARD_FILE_WRITE_DIR
-#  define USE_STANDARD_DIR_LOCATIONS
-#  define DB_HOST        "localhost"
-#  define DB_DB          "webboard"
-#  define DB_USERID      "braddr"
-#  define DB_PASSWORD    "adg1Qet"
+#  define NEED_SQL_ENVIRONMENT
+#  define ARG_HANDLE_USE_ONLY_GET_FORMAT
+#endif
+
+#ifdef SITE_GUML_COM
+#  define ACCTROOT	"/home/www-data/www.guml.org/root"
+#  define DATAROOT       ACCTROOT "/"
+#  define GUMLROOT       ACCTROOT "/"
+#  define USE_STANDARD_FILE_WRITE_DIR
+#  define ARG_HANDLE_USE_ONLY_GET_FORMAT
+#  define EXECGUML       ACCTROOT "/cgi-bin/actualbestguml"
+#  define LOGFILE        "/tmp/guml_log"
+#  define DB_ROOT        "/home/informix"
+#  define DB_HOST        "test_shm"
 #endif
 
 #ifdef SITE_INTRADEV
Index: oracle.c
===================================================================
RCS file: /cvsroot_private/guml/oracle.c,v
retrieving revision 1.5
diff -u -r1.5 oracle.c
--- oracle.c	5 Aug 1999 07:48:58 -0000	1.5
+++ oracle.c	28 Mar 2003 07:25:01 -0000
@@ -470,7 +470,7 @@
   }
 
   cmd.data = strdup(args[0]);
-  cmd.length = strlen(args[0]);
+  cmd.length = strlen(args[0])+1;
 
   if (oparse(&return_cursor, (text *) args[0], (sb4) -1,
             (sword) PARSE_NO_DEFER, (ub4) PARSE_V7_LNG)) {
Index: prims.c
===================================================================
RCS file: /cvsroot_private/guml/prims.c,v
retrieving revision 1.5
diff -u -r1.5 prims.c
--- prims.c	5 Aug 1999 07:48:58 -0000	1.5
+++ prims.c	28 Mar 2003 07:25:01 -0000
@@ -65,13 +65,11 @@
         return "\\get requires only 1 parameter";
 
     tmp_data = find_hash_data(args[0], calc_hash(args[0]));
-    if (!tmp_data)
-        return NULL;
 
-    if (!tmp_data->data)
+    if (!tmp_data)
         return NULL;
 
-    add_string (out_string, tmp_data->data);
+    add_string_data (out_string, tmp_data);
 
     return NULL;
 }
@@ -82,7 +80,8 @@
     if (nargs != 2)
         return "\\set requires 2 parameters";
 
-    insert_hash(strdup(args[0]), create_string(args[1], 0), calc_hash(args[0]), 0);
+    if (insert_hash(strdup(args[0]), create_string(args[1], 0), calc_hash(args[0]), 0))
+        return "\\set of a read only parameter is illegal";
 
     return NULL;
 }
@@ -171,9 +170,7 @@
     {
         if (res.data[0] == '\0')
             truth = 0;
-        free (res.data);
-        res.data = NULL;
-        res.length = 0;
+        free (res.data); // Clearing unnecessary, nothing uses res below
     }
     if (truth)
     {
Index: setup.c
===================================================================
RCS file: /cvsroot_private/guml/setup.c,v
retrieving revision 1.3
diff -u -r1.3 setup.c
--- setup.c	13 Sep 1999 08:23:17 -0000	1.3
+++ setup.c	28 Mar 2003 07:25:01 -0000
@@ -14,100 +14,138 @@
 extern FCGX_ParamArray fcgi_envp;
 #endif
 
-void setup_args (int iscomm, int argc, char *argv[])
+#ifdef BRADDR_TESTING
+void read_startup_config_file(void)
 {
-    char *env_ptr;
+    Data output;
+    FILE *g;
+    char *ptr;
 
-    /* set up the arguments */
-    if (iscomm)
-    {
-        if (argc > 2)
-            for (iscomm = 2; iscomm < argc; iscomm++)
-            {
-                char n[8];
+    if ((ptr = GETENV("GUML_CFGFILE")))
+        if ((g = fopen(ptr, "r")))
+        {
+            guml_file(&output, g);
+            fclose(g);
+        }
+}
 
-                sprintf (n, "ARG_%d", iscomm - 1);
-                insert_hash(strdup(n), create_string(argv[iscomm], 0), calc_hash(n), HASH_ARG);
-            }
+void read_per_page_hit_config_file(void)
+{
+    Data results, *ptr;
+    char *buf;
+
+    results.data = NULL;
+    results.length = 0;
+
+    ptr = find_hash_data("SERVERNAME", calc_hash("SERVERNAME"));
+    buf = malloc(strlen(ptr->data)+10);
+    sprintf (buf, "/headers/%s", ptr->data);
+    guml_file_include(&results, &buf, 1);
+    free(buf);
+}
+#endif
+
+void setup_commandline (int argc, char *argv[])
+{
+    int i;
+    char n[8], filename[256];
+
+    filename[0] = 0;
+    if (argc > 1)
+    {
+        strncpy (filename, argv[1], 255);
+        filename[255] = 0;
     }
-    else
+    insert_hash(strdup("FILENAME"), create_string(filename, 0), calc_hash("FILENAME"), HASH_ENV);
+    insert_hash(strdup("BASE_DIR"), create_string(GUMLROOT, 0), calc_hash("BASE_DIR"), HASH_ENV);
+
+    if (argc > 2)
     {
-#if defined(ARG_HANDLE_USE_ONLY_GET_FORMAT)
-        char *str, *p, *q;
- 
-        env_ptr = GETENV ("QUERY_STRING");
-        if (env_ptr)
+        for (i = 2; i < argc; i++)
         {
-            str = strdup (env_ptr);
-            p = strtok (str, "&");
-            while (p)
+            sprintf (n, "ARG_%d", i - 1);
+            insert_hash(strdup(n), create_string(argv[i], 0), calc_hash(n), HASH_ARG);
+        }
+    }
+}
+
+void setup_args ()
+{
+#if defined(ARG_HANDLE_USE_ONLY_GET_FORMAT)
+    char *env_ptr, *str, *p, *q;
+
+    env_ptr = GETENV ("QUERY_STRING");
+    if (env_ptr)
+    {
+        str = strdup (env_ptr);
+        p = strtok (str, "&");
+        while (p)
+        { 
+            q = strchr (p, '=');
+            if (q)
             { 
-                q = strchr (p, '=');
-                if (q)
-                { 
-                    *q = 0;
-                    q++;
-                    insert_hash(strdup(http_decode(p)), create_string(http_decode(q), 0), calc_hash(p), HASH_FORM);
-                }
-                p = strtok (NULL, "&");
+                *q = 0;
+                q++;
+                insert_hash(strdup(http_decode(p)), create_string(http_decode(q), 0), calc_hash(p), HASH_FORM);
             }
-            free(str);
+            p = strtok (NULL, "&");
         }
+        free(str);
+    }
 #elif defined(ARG_HANDLE_BOTH_FORMATS)
-        char *str, *str2, *p, *q, n[8];
-        int i;
+    char *env_ptr, *str, *str2, *p, *q, n[8];
+    int i;
 
-        env_ptr = GETENV ("QUERY_STRING");
-        if (env_ptr)
+    env_ptr = GETENV ("QUERY_STRING");
+    if (env_ptr)
+    {
+        str2 = strdup(env_ptr);
+        str = http_decode (strdup (env_ptr));
+        p = strtok (str, " ");
+        i = 1;
+        while (p && i < 10000)
         {
-            str2 = strdup(env_ptr);
-            str = http_decode (strdup (env_ptr));
-            p = strtok (str, " ");
-            i = 1;
-            while (p && i < 10000)
-            {
-                sprintf (n, "ARG_%d", i);
-                insert_hash(strdup(n), create_string(p, 0), calc_hash(n), HASH_ARG);
-                p = strtok (NULL, " ");
-                i++;
-            }
-            free (str);
+            sprintf (n, "ARG_%d", i);
+            insert_hash(strdup(n), create_string(p, 0), calc_hash(n), HASH_ARG);
+            p = strtok (NULL, " ");
+            i++;
+        }
+        free (str);
 
-            p = strtok (str2, "&");
-            while (p)
+        p = strtok (str2, "&");
+        while (p)
+        {
+            q = strchr (p, '=');
+            if (q)
             {
-                q = strchr (p, '=');
-                if (q)
-                {
-                    *q = 0;
-                    q++; 
-                    insert_hash(strdup(http_decode(p)), create_string(http_decode(q), 0), calc_hash(p), HASH_FORM);
-                }
-                p = strtok (NULL, "&");
+                *q = 0;
+                q++; 
+                insert_hash(strdup(http_decode(p)), create_string(http_decode(q), 0), calc_hash(p), HASH_FORM);
             }
-            free(str2);
+            p = strtok (NULL, "&");
         }
+        free(str2);
+    }
 #else
-        char *str, *p, n[8];
-        int i;
+    char *env_ptr, *str, *p, n[8];
+    int i;
 
-        env_ptr = GETENV ("QUERY_STRING");
-        if (env_ptr)
+    env_ptr = GETENV ("QUERY_STRING");
+    if (env_ptr)
+    {
+        str = http_decode (strdup (env_ptr));
+        p = strtok (str, " ");
+        i = 1;
+        while (p && i < 10000)
         {
-            str = http_decode (strdup (env_ptr));
-            p = strtok (str, " ");
-            i = 1;
-            while (p && i < 10000)
-            {
-                sprintf (n, "ARG_%d", i);
-                insert_hash(strdup(n), create_string(p, 0), calc_hash(n), HASH_ARG);
-                p = strtok (NULL, " ");
-                i++;
-            }
-            free (str);
+            sprintf (n, "ARG_%d", i);
+            insert_hash(strdup(n), create_string(p, 0), calc_hash(n), HASH_ARG);
+            p = strtok (NULL, " ");
+            i++;
         }
-#endif
+        free (str);
     }
+#endif
 }
 
 void setup_form_args (void)
@@ -176,12 +214,119 @@
     }
 }
 
+/*
+ * BASE_DIR == path to root of document tree, used for all file lookups, should end in a /
+ * FILENAME == append to BASE_DIR to load document to parse
+ * PATH     == FILENAME - the actual filename, ie the part between BASE_DIR and the final file to load
+ */
+void setup_path_and_filename ()
+{
+#ifdef OLD_PATH_METHOD
+    /* in old method, GUMLROOT set in local.h is BASE_DIR, env var PATH_INFO is filename */
+    char filename[256], *pi;
+
+    pi = GETENV ("PATH_INFO");
+    if (pi)
+    {
+        strncpy (filename, pi, 255);
+        filename[255] = 0;
+    }
+    else
+        filename[0] = 0;
+
+    if (strlen (filename) == 0)
+        strcpy (filename, "/file-not-found");
+
+    insert_hash(strdup("BASE_DIR"), create_string(GUMLROOT, 0), calc_hash("BASE_DIR"), HASH_ENV);
+    insert_hash(strdup("FILENAME"), create_string(filename, 0), calc_hash("FILENAME"), HASH_ENV);
+
+    if ((pi = strrchr (filename, '/')) != NULL)
+        *pi = 0;
+    insert_hash(strdup("PATH"), create_string(filename, 0), calc_hash("PATH"), HASH_ENV);
+#else
+    char filename[256], *pi, *pt, *pi_ptr, *pt_ptr, *pi_last_slash, *pt_last_slash;
+    Data *data;
+
+    pi = GETENV ("PATH_INFO");
+    pt = GETENV ("PATH_TRANSLATED");
+
+    if (!pi || !pt)
+    {  /* shouldn't ever happen, bad server config? */
+        insert_hash(strdup("BASE_DIR"), create_string(GUMLROOT, 0), calc_hash("BASE_DIR"), HASH_ENV);
+        insert_hash(strdup("FILENAME"), create_string("/file-not-found", 0), calc_hash("FILENAME"), HASH_ENV);
+        insert_hash(strdup("PATH"), create_string("/", 0), calc_hash("PATH"), HASH_ENV);
+	return;
+    }
+
+    if (!GETENV("REDIRECT_STATUS") && !GETENV("HTTP_REDIRECT_STATUS"))
+    {   /* not a redirect, setup from local.h */
+        insert_hash(strdup("BASE_DIR"), create_string(GUMLROOT, 0), calc_hash("BASE_DIR"), HASH_ENV);
+        insert_hash(strdup("FILENAME"), create_string(pi, 0), calc_hash("FILENAME"), HASH_ENV);
+
+        strcpy (filename, pi);
+        if (strrchr (filename, '/') != NULL)
+            *strrchr (filename, '/') = 0;
+        insert_hash(strdup("PATH"), create_string(filename, 0), calc_hash("PATH"), HASH_ENV);
+	return;
+    }
+   
+    /* examples:
+     * PATH_INFO=/inventory/index.ghtml
+     * PATH_TRANSLATED=/home/www-data/www.puremagic.org/root/inventory/index.ghtml
+     *
+     * PATH_INFO=/~braddr/movies/index.ghtml
+     * PATH_TRANSLATED=/home/braddr/public_html/movies/index.ghtml
+     */
+
+    /* point to end of strings */
+    pi_ptr = pi+strlen(pi)-1;
+    pt_ptr = pt+strlen(pt)-1;
+
+    /* work backwards to find filename from pi */
+    while (pi < pi_ptr && *pi_ptr != '/')
+	pi_ptr--;
+    pi_last_slash = pi_ptr;
+
+    /* work backwards to find filename from pt */
+    while (pt < pt_ptr && *pt_ptr != '/')
+	pt_ptr--;
+    pt_last_slash = pt_ptr;
+
+    /* work backwards while the two strings are the same */
+    while (pi < pi_ptr && pt < pt_ptr && *pt_ptr == *pi_ptr)
+    {
+	pi_ptr--;
+	pt_ptr--;
+    }
+    if (*pi_ptr != '/')
+	pi_ptr++;
+    if (*pt_ptr != '/')
+	pt_ptr++;
+
+    /* BASE_DIR will be the data between pt and pt_ptr, inclusive */
+    data = (Data*)malloc(sizeof(Data));
+    data->data = NULL;
+    data->length = 0;
+    add_string_size(data, pt, pt_ptr-pt+1);
+    insert_hash(strdup("BASE_DIR"), data, calc_hash("BASE_DIR"), HASH_ENV);
+
+    /* want to end of string, so no need to make our own temp string */
+    insert_hash(strdup("FILENAME"), create_string(pt_ptr, 0), calc_hash("FILENAME"), HASH_ENV);
+
+    /* PATH will be the data between pt_ptr and pt_last_lash, inclusive */
+    data = (Data*)malloc(sizeof(Data));
+    data->data = NULL;
+    data->length = 0;
+    add_string_size(data, pt_ptr, pt_last_slash-pt_ptr+1);
+    insert_hash(strdup("PATH"), data, calc_hash("PATH"), HASH_ENV);
+#endif
+}
+
 void setup_environment (int argc, char *argv[])
 {
-    Data *base_dir;
-    char *pi, *un, path[256], filename[256], *tmp, *tmp2;
+    char servername[256], *tmp;
     int iscomm;
-#if defined(DEBUG_ENV) || (defined(SITE_VISA_EXPO) && defined(DEVELOPMENT))
+#if defined(DEBUG_ENV)
     FILE *fp;
 #endif
 
@@ -194,161 +339,52 @@
     }
 #endif
 
-#if defined(USE_SYBASE) || defined(USE_ORACLE) || defined(USE_INFORMIX)
-#if defined(NEED_SQL_ENVIRONMENT)
-    sql_init_environ ();
-#endif
-#endif
-
     /* find out if we're off the "command line" */
-    tmp = GETENV ("HTTP_USER_AGENT");
+    tmp = GETENV ("REQUEST_METHOD");
     if (tmp)
-        insert_hash(strdup("HTTP_USER_AGENT"), create_string(tmp, 0), calc_hash("HTTP_USER_AGENT"), HASH_ENV);
+        insert_hash(strdup("REQUEST_METHOD"), create_string(tmp, 0), calc_hash("REQUEST_METHOD"), HASH_ENV);
 
     iscomm = (tmp == NULL);
     if (iscomm)
         insert_hash(strdup("USER"), create_string("manual", 0), calc_hash("USER"), HASH_ENV);
     else
     {
-        un = GETENV ("REMOTE_USER");
-        if (un)
-            insert_hash(strdup("USER"), create_string(un, 0), calc_hash("USER"), HASH_ENV);
+        tmp = GETENV ("REMOTE_USER");
+        if (tmp)
+            insert_hash(strdup("USER"), create_string(tmp, 0), calc_hash("USER"), HASH_ENV);
     }
 
-    filename[0] = 0;
+    servername[0] = 0;
     if (iscomm)
-        strcpy (filename, "localhost");
+        strcpy (servername, "localhost");
     else
     {
         tmp = GETENV ("SERVER_NAME");
         if (tmp)
         {
-            strncpy (filename, tmp, 240);
-            filename[240] = 0;
-            insert_hash(strdup("SERVERDOMAIN"), create_string(filename, 0), calc_hash("SERVERDOMAIN"), HASH_ENV);
+            strncpy (servername, tmp, 240);
+            servername[240] = 0;
+            insert_hash(strdup("SERVERDOMAIN"), create_string(servername, 0), calc_hash("SERVERDOMAIN"), HASH_ENV);
         }
         tmp = GETENV ("SERVER_PORT");
         if (tmp)
             if (atoi (tmp) != 80 && atoi (tmp) != 443)
             {
-                sprintf (path, ":%d", atoi (tmp));
-                strcat (filename, path);
+                strcat (servername, ":");
+                strcat (servername, tmp);
             }
     }
-    insert_hash(strdup("SERVERNAME"), create_string(filename, 0), calc_hash("SERVERNAME"), HASH_ENV);
-
-    setup_args (iscomm, argc, argv);
-    setup_form_args ();
-    setup_cookie_args ();
+    insert_hash(strdup("SERVERNAME"), create_string(servername, 0), calc_hash("SERVERNAME"), HASH_ENV);
 
     if (iscomm)
-    {
-        if (argc > 1)
-        {
-            strncpy (filename, argv[1], 255);
-            filename[255] = 0;
-        }
-        else
-            filename[0] = 0;
-        insert_hash(strdup("BASE_DIR"), create_string(GUMLROOT, 0), calc_hash("BASE_DIR"), HASH_ENV);
-    }
+	setup_commandline(argc, argv);
     else
     {
-        pi = GETENV ("PATH_INFO");
-#ifdef OLD_PATH_METHOD
-        if (pi)
-        {
-            strncpy (filename, pi, 255);
-            filename[255] = 0;
-        }
-        else
-            filename[0] = 0;
-        insert_hash(strdup("BASE_DIR"), create_string(GUMLROOT, 0), calc_hash("BASE_DIR"), HASH_ENV);
-#else
-        if (GETENV("REDIRECT_STATUS") || GETENV("HTTP_REDIRECT_STATUS"))
-        {    /* redirected cgi-bin call */
-            tmp = GETENV("PATH_TRANSLATED");
-            if (tmp)
-            {
-                base_dir = (Data*)malloc(sizeof(Data));
-                base_dir->data = NULL;
-                base_dir->length = 0;
-#if defined(SITE_VISA_EXPO) && defined(DEVELOPMENT)
-                if (strncmp("/iwmnt/", tmp, 7) == 0)
-                {
-                    add_string(base_dir, IWVPATH " -a ");
-                    add_string(base_dir, tmp);
-                    add_string(base_dir, " 2> /dev/null");
-                    fp = popen(base_dir->data, "r");
-                    iscomm = fread(base_dir->data, 1, base_dir->length, fp);
-                    pclose(fp);
-                    if (iscomm == 0) {
-                        free(base_dir->data);
-                        base_dir->data = NULL;
-                        base_dir->length = 0;
-                        un = strdup(tmp);
-                        iscomm = strlen(tmp) - strlen(pi);
-                        un[iscomm] = 0;
-                        add_string_size(base_dir, un, iscomm);
-                        if (un[iscomm-1] != '/')
-                            add_char(base_dir, '/');
-                        free(un);
-                    } else {
-                        base_dir->data[iscomm] = 0;
-                        if (base_dir->data[iscomm-1] == '\n')
-                            base_dir->data[--iscomm] = 0;
-                        if (base_dir->data[iscomm-1] != '/')
-                            strcat(base_dir->data, "/");
-                        tmp = strstr(tmp, base_dir->data);
-                        pi = tmp + strlen(base_dir->data)-1;
-                    }
-                }
-                else
-                {
-#endif
-                    un = strdup(tmp);
-
-                    /* If PATH_TRANSLATED ends in /filename then chop that */
-                    if (un[strlen(un)-1] != '/' && (tmp2 = strrchr(un, '/')) != NULL && tmp2 != un)
-                        tmp2[1] = 0;
-
-                    /* if PATH_INFO contains a directory then it should be chopped from PATH_TRANSLATED */
-                    if ((tmp2 = strrchr(pi, '/')) != NULL && tmp2 != pi)
-                        un[strlen(un) - (tmp2 - pi)] = 0;
-
-                    add_string(base_dir, un);
-                    free(un);
-#if defined(SITE_VISA_EXPO) && defined(DEVELOPMENT)
-                }
-#endif
-                insert_hash(strdup("BASE_DIR"), base_dir, calc_hash("BASE_DIR"), HASH_ENV);
-            }
-            else
-                insert_hash(strdup("BASE_DIR"), create_string(GUMLROOT, 0), calc_hash("BASE_DIR"), HASH_ENV);
-        }
-        else
-            insert_hash(strdup("BASE_DIR"), create_string(GUMLROOT, 0), calc_hash("BASE_DIR"), HASH_ENV);
-
-        if (pi)
-        {
-            strncpy (filename, pi, 255);
-            filename[255] = 0;
-        }
-        else
-            filename[0] = 0;
-#endif
+        setup_args ();
+        setup_path_and_filename ();
     }
-
-    if (strlen (filename) == 0)
-        strcpy (filename, "/file-not-found");
-
-    /* set up path appropriately */
-    insert_hash(strdup("FILENAME"), create_string(filename, 0), calc_hash("FILENAME"), HASH_ENV);
-
-    strcpy (path, filename);
-    if (strrchr (path, '/') != NULL)
-        *strrchr (path, '/') = 0;
-    insert_hash(strdup("PATH"), create_string(path, 0), calc_hash("PATH"), HASH_ENV);
+    setup_form_args ();
+    setup_cookie_args ();
 
     tmp = GETENV ("SCRIPT_NAME");
     if (tmp)
@@ -358,9 +394,9 @@
     if (tmp)
         insert_hash(strdup("HTTP_REFERER"), create_string(tmp, 0), calc_hash("HTTP_REFERER"), HASH_ENV);
 
-    tmp = GETENV ("REQUEST_METHOD");
+    tmp = GETENV ("HTTP_USER_AGENT");
     if (tmp)
-        insert_hash(strdup("REQUEST_METHOD"), create_string(tmp, 0), calc_hash("REQUEST_METHOD"), HASH_ENV);
+        insert_hash(strdup("HTTP_USER_AGENT"), create_string(tmp, 0), calc_hash("HTTP_USER_AGENT"), HASH_ENV);
 
     tmp = GETENV ("REMOTE_HOST");
     if (tmp)
Index: site_specific_ops.c
===================================================================
RCS file: /cvsroot_private/guml/site_specific_ops.c,v
retrieving revision 1.2
diff -u -r1.2 site_specific_ops.c
--- site_specific_ops.c	26 Nov 1997 00:27:36 -0000	1.2
+++ site_specific_ops.c	28 Mar 2003 07:25:01 -0000
@@ -1,4 +1,5 @@
 #include <stdlib.h>
+#include <stdio.h>
 #ifdef NEED_CRYPT
 #include <crypt.h>
 #endif
Index: string_ops.c
===================================================================
RCS file: /cvsroot_private/guml/string_ops.c,v
retrieving revision 1.9
diff -u -r1.9 string_ops.c
--- string_ops.c	13 Oct 1999 19:55:31 -0000	1.9
+++ string_ops.c	28 Mar 2003 07:25:01 -0000
@@ -302,11 +302,17 @@
 
 char *guml_strcmp(Data *out_string, char *args[], int nargs)
 {
+    int rc;
+
     if (nargs != 2)
-      return "\\strcmp requires 2 arguments!";
+        return "\\strcmp requires 2 arguments!";
 
-    if (strcmp(args[0],args[1])>0)
-      add_string_size(out_string,"true",4);
+    if ((rc = strcmp(args[0], args[1])) > 0)
+        add_char(out_string, '1');
+    else if (rc == 0)
+        add_char(out_string, '0');
+    else
+        add_string_size(out_string, "-1", 2);
 
     return NULL;
 }
Index: string_utils.c
===================================================================
RCS file: /cvsroot_private/guml/string_utils.c,v
retrieving revision 1.4
diff -u -r1.4 string_utils.c
--- string_utils.c	5 Aug 1999 07:48:58 -0000	1.4
+++ string_utils.c	28 Mar 2003 07:25:01 -0000
@@ -51,7 +51,7 @@
         Data *tmp = malloc(sizeof(Data));
 
         tmp->data = no_dup ? str : strdup(str);
-        tmp->length = strlen(str);
+        tmp->length = strlen(str)+1;
         return tmp;
 }
 
@@ -76,7 +76,7 @@
 /* Make sure that str has enough space to append atleast 'add' characters */
 #define SPACE_MASK (((unsigned long)-1) ^ 0xFFF)
 
-inline void check_space (Data *str, int add)
+INLINE void check_space (Data *str, int add)
 {
     if (!(str->length))
         add++;
@@ -92,7 +92,7 @@
 }
 
 /* add c to the end of str */
-inline void add_char (Data *str, char c)
+INLINE void add_char (Data *str, char c)
 {
     check_space (str, 1);
     str->data[str->length - 1] = c;
@@ -100,7 +100,7 @@
 }
 
 /* add s2 to the end of s1 */
-inline void add_string (Data *s1, char *s2)
+INLINE void add_string (Data *s1, char *s2)
 {
     int s2_len = strlen(s2);
 
@@ -112,7 +112,7 @@
 }
 
 /* add s2 to the end of s1 */
-inline void add_string_size (Data *s1, char *s2, unsigned long s2_len)
+INLINE void add_string_size (Data *s1, char *s2, unsigned long s2_len)
 {
     if (!s2_len)
         return;
@@ -122,13 +122,13 @@
     s1->data[s1->length-1] = 0;
 }
 
-inline void add_string_data (Data *s1, Data *s2)
+INLINE void add_string_data (Data *s1, Data *s2)
 {
     if (!s2->length)
         return;
     check_space (s1, s2->length);
-    strncpy (s1->data + s1->length - 1, s2->data, s2->length + 1);
-    s1->length += s2->length;
+    strncpy (s1->data + s1->length - 1, s2->data, s2->length);
+    s1->length += s2->length - 1;  /* don't account for 2 nulls */
 }
 
 int split_string(char *str, char split, char **w1, char **w2)
Index: test_hash.c
===================================================================
RCS file: /cvsroot_private/guml/test_hash.c,v
retrieving revision 1.4
diff -u -r1.4 test_hash.c
--- test_hash.c	5 Aug 1999 07:48:58 -0000	1.4
+++ test_hash.c	28 Mar 2003 07:25:01 -0000
@@ -21,7 +21,7 @@
 	Data *tmp = malloc(sizeof(Data));
 
 	tmp->data = no_dup ? str : strdup(str);
-	tmp->length = strlen(str);
+	tmp->length = strlen(str)+1;
 	return tmp;
 }
 
@@ -31,7 +31,7 @@
 	Data *tmp_data, *tmp_data2;
         int i;
 
-	init_env();
+	init_hash_table();
 
 	for (i=0; i<10000; i++)
 	{
